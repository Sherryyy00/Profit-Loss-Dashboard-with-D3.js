<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Profit Breakdown Waterfall Chart</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      /* font-family: sans-serif; */
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }
    .increase {
      fill: #22c55e;
    }
    .decrease {
      fill: #ef4444;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 6px;
      font-size: 12px;
      background: #fff;
      border: 1px solid #aaa;
      pointer-events: none;
    }
    .legend {
      font-size: 11px;
      cursor: pointer;
    }
    .hidden {
      display: none;
    }
    .sortable {
        cursor: pointer;
        user-select: none;
    }
    .sortable:hover {
        background-color: #e8e8e8;
    }
    .sortable::after {
        content: ' \2195';
        font-size: 12px;
        color: #999;
        padding-left: 5px;
    }
    .sortable.asc::after {
        content: ' \25B2';
        color: #000;
    }
    .sortable.desc::after {
        content: ' \25BC'; 
        color: #000;
    }
  </style>
</head>
<body>

<h2 style="text-align:center; margin-right:200px;">Amazon's Global Profit Analysis</h2>

<div style="display: flex; align-items: flex-start; margin-left: 80px;">
  <svg width="1100" height="600"></svg>

  <div id="data-table" style="margin-left: 60px;">
    <h3 style="margin-left: 60px;">Profit Breakdown Table</h3>
    <table cellpadding="8" cellspacing="0" style="border-collapse: collapse; font-size: 14px; width: 300px;">
      <thead>
        <tr style="background-color: #f0f0f0;">
          <th class="sortable" data-column="Country">Country</th>
          <th class="sortable" data-column="Profit">Profit</th>
          <th class="sortable" data-column="Type">Type</th>
        </tr>
      </thead>
      <tbody id="table-body">
        </tbody>
    </table>
    
  </div>
</div>
  <script>
    let currentTableData = [];
    let sortState = { column: null, ascending: true };

    const svg = d3.select("svg"),
          margin = {top: 50, right: 30, bottom: 120, left: 80},
          width = +svg.attr("width") - margin.left - margin.right,
          height = +svg.attr("height") - margin.top - margin.bottom;

    const chart = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    d3.json("WaterfallData.json").then(rawData => {
      const profitMap = d3.rollups(
        rawData,
        v => d3.sum(v, d => +d.Profit.replace(/[$,]/g, "")),
        d => d.Country
      );

      const data = profitMap.map(([country, profit]) => ({
        Country: country,
        Profit: +profit
      })).sort((a, b) => Math.abs(b.Profit) - Math.abs(a.Profit))
        .slice(0,30);

      let cumulative = 0;
      data.forEach(d => {
        d.start = cumulative;
        d.end = d.Profit >= 0 ? cumulative + d.Profit : cumulative + d.Profit;
        cumulative = d.end;
        d.class = d.Profit >= 0 ? "increase" : "decrease";
      });
      
      currentTableData = [...data];

      const x = d3.scaleBand()
        .domain(data.map(d => d.Country))
        .range([0, width])
        .padding(0.3);

      const y = d3.scaleLinear()
        .domain([d3.min(data, d => Math.min(d.start, d.end)), d3.max(data, d => Math.max(d.start, d.end))])
        .range([height, 0])
        .nice();

      chart.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end")
        chart.append("text")
          .attr("x", width / 2)
          .attr("y", height + 90)
          .style("text-anchor", "middle")
          .style("font-size", "14px")
          .style("fill", "rgb(40, 40, 40)")
          .text("Country");

      chart.append("g")
        .call(d3.axisLeft(y).tickFormat(d => d3.format(".2s")(d).replace("G", "B")));
        chart.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -75)
        .attr("x", -height / 2)
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .style("font-size", "14px")
        .style("fill", "rgb(40, 40, 40)")
        .text("Profit");

      const barsGroup = chart.append("g").attr("class", "bars");

      function updateBars(filteredData) {
        const bars = barsGroup.selectAll("rect")
          .data(filteredData, d => d.Country);
        bars.exit().remove();
        bars.enter()
          .append("rect")
          .attr("x", d => x(d.Country))
          .attr("y", y(0))
          .attr("height", 0)
          .attr("width", x.bandwidth())
          .attr("class", d => d.class)
          .on("mouseover", (event, d) => {
            tooltip.transition().duration(200).style("opacity", .9);
            tooltip.html(`<strong>${d.Country}</strong><br/>Profit: ${d3.format("$.2s")(d.Profit).replace("G", "B")}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0))
          .transition()
          .duration(800)
          .delay((d, i) => i * 100)
          .attr("y", d => y(Math.max(d.start, d.end)))
          .attr("height", d => Math.abs(y(d.start) - y(d.end)));
      }

      function updateTable(dataForTable) {
        const tbody = d3.select("#table-body");
        tbody.selectAll("tr").remove();

        const formatProfit = d3.format(".2s");

        //Limit to 15 records
        const tableDisplayData = dataForTable.slice(0, 15);

        tableDisplayData.forEach(d => {
          const row = tbody.append("tr");
          row.append("td").text(d.Country);
          row.append("td").text(formatProfit(d.Profit).replace("G", "B"));
          row.append("td").text(d.class === "increase" ? "Increase" : "Decrease");
        });
      }

      updateBars(data);
      updateTable(data);

      const legendData = [
        { label: "Increase", color: "#22c55e", filter: "increase" },
        { label: "Decrease", color: "#ef4444", filter: "decrease" },
        { label: "Total", color: "#3b82f6", filter: "all" }
      ];

      const legend = svg.append("g")
        .attr("transform", `translate(${margin.left},20)`)
        .selectAll("g")
        .data(legendData)
        .enter().append("g")
        .attr("transform", (d, i) => `translate(${i * 75}, 0)`)
        .style("cursor", "pointer")
        .on("click", (event, d) => {
          if (d.filter === "all") {
            currentTableData = [...data];
            updateBars(data);
            updateTable(data);
          } else {
            const filtered = data.filter(item => item.class === d.filter);
            currentTableData = filtered;
            updateBars(filtered);
            updateTable(filtered);
          }
           sortState = { column: null, ascending: true };
           //Reset visual sort indicators when filter changes
           d3.selectAll("#data-table th.sortable").classed("asc", false).classed("desc", false);
        });
      legend.append("circle")
        .attr("cx", 10)
        .attr("cy", 14)
        .attr("r", 6)
        .attr("fill", d => d.color);
      legend.append("text")
        .attr("x", 20)
        .attr("y", 18)
        .text(d => d.label)
        .attr("class", "legend");

      // Sorting logic is now inside the .then() block for cleaner access to updateTable
      d3.selectAll("#data-table th.sortable").on("click", function() {
        const column = d3.select(this).attr("data-column");

        if (sortState.column === column) {
            sortState.ascending = !sortState.ascending;
        } else {
            sortState.column = column;
            sortState.ascending = true;
        }

        currentTableData.sort((a, b) => {
            let valA = (column === 'Type') ? a.class : a[column];
            let valB = (column === 'Type') ? b.class : b[column];

            if (typeof valA === 'string') {
                return sortState.ascending ? valA.localeCompare(valB) : valB.localeCompare(valA);
            } else {
                return sortState.ascending ? valA - valB : valB - valA;
            }
        });

        //Update header classes to show correct sort indicator
        d3.selectAll("#data-table th.sortable").classed("asc", false).classed("desc", false);
        d3.select(this).classed(sortState.ascending ? "asc" : "desc", true);
        
        // Redraw the table
        updateTable(currentTableData);
      });
    });
  </script>
</body>
</html>